import{_ as s,r as d,o as r,c as l,a as e,b as a,w as c,e as i,d as t}from"./app.1e1d5899.js";const h={},u=i('<h1 id="vmess-protocol" tabindex="-1"><a class="header-anchor" href="#vmess-protocol" aria-hidden="true">#</a> VMess protocol</h1><p>VMess is the original encrypted communication protocol of V2Ray.</p><h2 id="protocol-version" tabindex="-1"><a class="header-anchor" href="#protocol-version" aria-hidden="true">#</a> Protocol version</h2><p>The current version number is 1.</p><h2 id="principals" tabindex="-1"><a class="header-anchor" href="#principals" aria-hidden="true">#</a> Principals</h2><h3 id="transport" tabindex="-1"><a class="header-anchor" href="#transport" aria-hidden="true">#</a> Transport</h3><p>VMess is a TCP-based protocol, and all data is transferred using TCP.</p><h3 id="user-id" tabindex="-1"><a class="header-anchor" href="#user-id" aria-hidden="true">#</a> User ID</h3>',8),y=t("ID is equivalent to "),p={href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",target:"_blank",rel:"noopener noreferrer"},m=t("UUID"),b=t(", a 16-byte long random hexadecimal string that acts as a Token. Example of a UUID: de305d54-75b4-431b-adb2-eb6b9e546014; almost fully randomized, and can be generated using any UUID generator, such as "),f={href:"https://www.uuidgenerator.net/",target:"_blank",rel:"noopener noreferrer"},g=t("this"),x=t("."),_=t("The user ID can be specified in the "),C=t("configuration file"),v=t("."),k=e("h3",{id:"functions",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#functions","aria-hidden":"true"},"#"),t(" Functions")],-1),M=t("MD5: "),T={href:"https://en.wikipedia.org/wiki/MD5",target:"_blank",rel:"noopener noreferrer"},A=t("MD5 function"),P=e("ul",null,[e("li",null,"Input is a byte array of arbitrary length"),e("li",null,"Output is a 16 byte array")],-1),I=t("HMAC: "),w={href:"https://en.wikipedia.org/wiki/Hash-based_message_authentication_code",target:"_blank",rel:"noopener noreferrer"},V=t("HMAC function"),D=e("ul",null,[e("li",null,[t("Input parameters: "),e("ul",null,[e("li",null,"H: Hash function"),e("li",null,"K: Key, arbitrary length byte array"),e("li",null,"M: Message, arbitrary length byte array")])])],-1),S=t("Shake: "),E={href:"https://en.wikipedia.org/wiki/SHA-3",target:"_blank",rel:"noopener noreferrer"},B=t("SHA3-Shake128 function"),R=e("ul",null,[e("li",null,"Input is a string of arbitrary length"),e("li",null,"Output is a string of arbitrary length")],-1),L=i('<h2 id="communication-process" tabindex="-1"><a class="header-anchor" href="#communication-process" aria-hidden="true">#</a> Communication process</h2><p>VMess is a stateless protocol. That is, the client and server do not need to handshake to directly transfer data, and each data transfer does not affect other data transfers before or after it. The VMess client initiates a request, and the server determines whether the request comes from a legitimate client. If the verification passes, the request is forwarded and the response is returned to the client. VMess uses an asymmetric format. That is, the request sent by the client and the response replied by the server use different formats.</p><h2 id="client-request" tabindex="-1"><a class="header-anchor" href="#client-request" aria-hidden="true">#</a> Client request</h2><table><thead><tr><th>16 bytes</th><th>X bytes</th><th>Remaining Payload</th></tr></thead><tbody><tr><td>Authentication</td><td>Command</td><td>Data...</td></tr></tbody></table><h3 id="authentication" tabindex="-1"><a class="header-anchor" href="#authentication" aria-hidden="true">#</a> Authentication</h3><p>The Authentication header is a 16-byte hash value, which is calculated as follows:</p><ul><li>H = MD5</li><li>K = User ID (16 bytes)</li><li>M = UTC time, accurate to seconds, the value is the current time plus or minus 30 seconds (8 bytes, Big Endian)</li><li>Hash = HMAC(H, K, M)</li></ul><h3 id="command" tabindex="-1"><a class="header-anchor" href="#command" aria-hidden="true">#</a> Command</h3><p>The Command header is encrypted by AES-128-CFB:</p><ul><li>Key: MD5(User ID + []byte(&#39;c48619fe-8f02-49e0-b9e9-edf763e17e21&#39;))</li><li>IV: MD5(X + X + X + X), X = []byte (UTC time at authentication header generation) (8 bytes, Big Endian)</li></ul><table><thead><tr><th style="text-align:center;">1 byte</th><th style="text-align:center;">16 bytes</th><th style="text-align:center;">16 bytes</th><th style="text-align:center;">1 byte</th><th style="text-align:center;">1 byte</th><th style="text-align:center;">4 bit</th><th style="text-align:center;">4 bit</th><th style="text-align:center;">1 byte</th><th style="text-align:center;">1 byte</th><th style="text-align:center;">2 bytes</th><th style="text-align:center;">1 byte</th><th style="text-align:center;">N bytes</th><th style="text-align:center;">P byte</th><th style="text-align:center;">4 bytes</th></tr></thead><tbody><tr><td style="text-align:center;">Version <code>Ver</code></td><td style="text-align:center;">Encryption <code>IV</code></td><td style="text-align:center;">Encryption <code>Key</code></td><td style="text-align:center;">Response Auth Pad <code>V</code></td><td style="text-align:center;">Options <code>Opt</code></td><td style="text-align:center;">Padding <code>P</code></td><td style="text-align:center;">Encryption Algorithm <code>Sec</code></td><td style="text-align:center;"><code>Keep</code></td><td style="text-align:center;">Command <code>Cmd</code></td><td style="text-align:center;"><code>Port</code></td><td style="text-align:center;">Address Type <code>T</code></td><td style="text-align:center;">Address <code>A</code></td><td style="text-align:center;">Random Padding</td><td style="text-align:center;">Message Checksum <code>F</code></td></tr></tbody></table><p>Option <code>Opt</code> details: (A bit set to 1 enables the option)</p><table><thead><tr><th style="text-align:center;">0</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th></tr></thead><tbody><tr><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">M</td><td style="text-align:center;">R</td><td style="text-align:center;">S</td></tr></tbody></table><p>Where:</p><ul><li>Version <code>Ver</code>: Currently always <code>1</code>;</li><li>Encryption <code>IV</code>: random value;</li><li>Encryption <code>Key</code>: random value;</li><li>Response Auth Pad <code>V</code>: random value;</li><li>Options <code>Opt</code>: <ul><li>S (<code>0x01</code>): standard format data stream (recommended to open);</li><li>R (<code>0x02</code>): The client expects to reuse TCP connections (V2Ray 2.23+ deprecated);</li><li>Only valid when S is also enabled;</li><li>M (<code>0x04</code>): Enable metadata obfuscation (Recommended); <ul><li>Only valid when S is also enabled;</li><li>While enabled, the client and server need to construct two Shake instances separately: RequestMask = Shake (request data IV), and ResponseMask = Shake (response data IV).</li></ul></li><li>X: Reserved</li></ul></li><li>Padding <code>P</code>: Pad with P bytes of random data;</li><li>Encryption Algorithm <code>Sec</code>: Specify the encryption method of the data payload: <ul><li><code>0x00</code>: AES-128-CFB;</li><li><code>0x01</code>: No encryption;</li><li><code>0x02</code>: AES-128-GCM;</li><li><code>0x03</code>: ChaCha20-Poly1305;</li></ul></li><li>Command <code>Cmd</code>: <ul><li><code>0x01</code>: TCP data;</li><li><code>0x02</code>: UDP data;</li></ul></li><li><code>Port</code>: Integer destination port number in Big Endian format;</li><li>Address Type <code>T</code>: <ul><li><code>0x01</code>: IPv4</li><li><code>0x02</code>: Domain name</li><li><code>0x03</code>: IPv6</li></ul></li><li>Address <code>A</code>: <ul><li>While T = <code>0x01</code>, A is a 4-byte IPv4 address;</li><li>While T = <code>0x02</code>, A is 1-byte length parameter (L) + L-byte length domain name;</li><li>While T = <code>0x03</code>, A is a 16-byte IPv6 address;</li></ul></li><li>Message Checksum <code>F</code>: FNV1a hash of all contents except F in the Command header;</li></ul><h3 id="data-payload" tabindex="-1"><a class="header-anchor" href="#data-payload" aria-hidden="true">#</a> Data payload</h3><p>Two data formats are supported, defaulting to the Basic format:</p><h4 id="basic-format-deprecated" tabindex="-1"><a class="header-anchor" href="#basic-format-deprecated" aria-hidden="true">#</a> Basic format (Deprecated)</h4><p>**This format is included only for backward compatibility reasons and may be removed in future versions. **</p><p>All data is assumed to be the actual content of the client&#39;s request. This content will be sent to the address specified in the Command header. If <code>Cmd</code> = <code>0x01</code>, data will be sent in TCP form; If <code>Cmd</code> = <code>0x02</code>, data will be sent in UDP form.</p><p>This format supports two encryption options: &quot;unencrypted&quot; and &quot;AES-128-CFB&quot;. The encryption Key and IV are specified by the Command header.</p><h4 id="standard-format" tabindex="-1"><a class="header-anchor" href="#standard-format" aria-hidden="true">#</a> Standard Format</h4><p>When <code>Opt(S)</code> is enabled, the Data payload uses this format. The actual request data is divided into several small blocks, and the format of each block is as follows. After the server verifies the integrity of all blocks, it forwards them similarly to the basic format.</p><table><thead><tr><th style="text-align:center;">2 bytes</th><th style="text-align:center;">L bytes</th></tr></thead><tbody><tr><td style="text-align:center;">Length L</td><td style="text-align:center;">Data Packet</td></tr></tbody></table><p>Where:</p><ul><li>Length L: Big Endian integer, maximum value 2^14; <ul><li>When <code>Opt(M)</code> is enabled, L is set to <code>xor Mask.Mask = (RequestMask.NextByte() &lt;&lt; 8) + RequestMask.NextByte()</code>;</li></ul></li><li>Data Packet: Block encrypted by the specified encryption method;</li></ul><p>Before the end of transmission, there must be actual data present in the data packet. That is, data other than the length L and headers. When the transmission ends, the client shall send an empty data packet of zero length L (not encrypted), or the length of the authentication header (encrypted), to indicate the end of transmission.</p><p>Depending on the encryption method, the format of the data packet is as follows:</p><ul><li>Unencrypted: <ul><li>L bytes: Actual data payload;</li></ul></li><li>AES-128-CFB: Payload is encrypted with AES-128-CFB <ul><li>4 bytes: FNV1a hash of actual data payload (Big-Endian);</li><li>L-4 bytes: Actual data payload;</li></ul></li><li>AES-128-GCM: Key is specified in Command header, IV = count (2 bytes) + IV (10 bytes). Count starts from 0 and increases by 1 for each data packet; IV is the bytes 3 to 12 of the Command header <code>IV</code>. <ul><li>L-16 bytes: Actual data payload;</li><li>16 bytes: GCM authentication code</li></ul></li><li>ChaCha20-Poly1305: Key = MD5 (Command header <code>Key</code>) + MD5 (MD5 (Command header <code>Key</code>)), IV = count (2 bytes) + IV (10 bytes). Count starts from 0 and increases by 1 for each data packet; IV is bytes 3 to 12 of the Command header <code>IV</code>. <ul><li>L-16 bytes: Actual data payload;</li><li>16 bytes: Poly1305 authentication information</li></ul></li></ul><h2 id="server-response" tabindex="-1"><a class="header-anchor" href="#server-response" aria-hidden="true">#</a> Server response</h2><p>The header data of the response is encrypted with AES-128-CFB, where the IV is MD5 (data encryption IV), and the Key is MD5 (data encryption Key). The actual response data varies depending on the encryption settings.</p><table><thead><tr><th>1 byte</th><th>1 byte</th><th>1 byte</th><th>1 byte</th><th>M byte</th><th>Remaining Data</th></tr></thead><tbody><tr><td>Response Auth Pad <code>V</code></td><td>Options <code>Opt</code></td><td>Command <code>Cmd</code></td><td>Command Length <code>M</code></td><td>Command Payload</td><td>Actual response data payload</td></tr></tbody></table><p>Where:</p><ul><li>Response Auth Pad <code>V</code>: must be the same as the Response Auth Pad <code>V</code> in the client request;</li><li>Options <code>Opt</code>: <ul><li>0x01: The server can reuse this TCP connection (obsoleted since v2.23);</li></ul></li><li>Command <code>Cmd</code>: <ul><li>0x01: Use dynamic port (See <a href="#Dynamic-Port-Command">Dynamic Port Command</a>)</li></ul></li><li>Actual response data: <ul><li>If <code>Opt(S)</code> was enabled in the request, the standard format is used, otherwise default to the basic format.</li><li>When Opt(M) is enabled, L is set to <code>xor Mask.Mask = (ResponseMask.NextByte() &lt;&lt; 8) + ResponseMask.NextByte()</code>;</li></ul></li></ul><h3 id="dynamic-port-command" tabindex="-1"><a class="header-anchor" href="#dynamic-port-command" aria-hidden="true">#</a> Dynamic Port Command</h3><table><thead><tr><th>1 byte</th><th>2 byte</th><th>16 byte</th><th>2 byte</th><th>1 byte</th><th>1 byte</th></tr></thead><tbody><tr><td>Reserved</td><td>Port</td><td>User ID</td><td>AlterID</td><td>User level</td><td>TTL <code>T</code></td></tr></tbody></table><p>Where:</p><ul><li>Port: Big Endian integer port number;</li><li>Time-To-Live <code>T</code>: Time in minutes;</li></ul><p>If a client receives the dynamic port command, the server has opened a new dynamic port, which the client can utilize to send future data. After T minutes, this port is invalidated and the client must revert to using the main port again.</p><h2 id="notes" tabindex="-1"><a class="header-anchor" href="#notes" aria-hidden="true">#</a> Notes</h2><ul><li>To ensure backward compatibility, the values of all reserved fields must be 0.</li></ul>',41);function q(U,O){const n=d("ExternalLinkIcon"),o=d("RouterLink");return r(),l("div",null,[u,e("p",null,[y,e("a",p,[m,a(n)]),b,e("a",f,[g,a(n)]),x]),e("p",null,[_,a(o,{to:"/en_US/developer/config/overview.html"},{default:c(()=>[C]),_:1}),v]),k,e("ul",null,[e("li",null,[M,e("a",T,[A,a(n)]),P]),e("li",null,[I,e("a",w,[V,a(n)]),D]),e("li",null,[S,e("a",E,[B,a(n)]),R])]),L])}const F=s(h,[["render",q],["__file","vmess.html.vue"]]);export{F as default};
